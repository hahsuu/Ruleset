name: Generate JSON Files from List Files

on:
  push:
    paths:
      - "*.list"
  workflow_dispatch:

concurrency:
  group: json-updater-${{ github.ref }}
  cancel-in-progress: true

jobs:
  generate-and-push:
    runs-on: ubuntu-22.04
    permissions:
      contents: write

    steps:
      # 阶段1：深度检出（带完整历史）
      - name: Checkout with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      # 阶段2：建立原子锁
      - name: Create Atomic Lock
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # 生成唯一锁标记
          lock_tag="lock-$(date +%s)"
          git tag $lock_tag
          git push origin $lock_tag
          echo "LOCK_TAG=$lock_tag" >> $GITHUB_ENV

      # 阶段3：实时同步
      - name: Live Synchronization
        run: |
          # 每5秒同步一次直到超时
          timeout 60 bash -c '
            while ! git fetch --all --prune --tags; do
              sleep 1
            done;
            git reset --hard origin/${{ github.ref_name }}
            git clean -ffdx
          ' || (echo "同步超时"; exit 1)

          # 验证锁标记
          if ! git tag --list $LOCK_TAG; then
            echo "原子锁丢失，终止流程"
            exit 1
          fi

      # 阶段4：文件生成
      - name: Generate JSON Files
        run: |
          # 清理旧文件（兼容手动删除）
          find . -name "*.json" -delete 2>/dev/null || true
          
          python generate_json.py
          
          # 严格验证输出
          json_count=$(find . -name "*.json" | wc -l)
          if [ $json_count -eq 0 ]; then
            echo "生成失败：未检测到JSON文件"
            exit 1
          fi

      # 阶段5：原子提交
      - name: Atomic Commit
        run: |
          git add -A
          if git diff-index --quiet HEAD --; then
            echo "无变更需要提交"
            exit 0
          fi

          # 生成防冲突时间戳
          timestamp=$(date -u +"%Y%m%d-%H%M%S-%3N")
          git commit -m "AutoUpdate-$timestamp"

          # 实时变基
          git pull --rebase origin ${{ github.ref_name }} || (
            git rebase --abort
            echo "变基冲突，执行强制同步"
            git reset --hard origin/${{ github.ref_name }}
            git clean -ffdx
            exit 1
          )

      # 阶段6：原子推送
      - name: Atomic Push
        run: |
          for i in {1..5}; do
            git fetch origin
            
            # 使用双重校验推送
            if git push origin HEAD:${{ github.ref_name }} \
              --force-with-lease=refs/remotes/origin/${{ github.ref_name }}:refs/tags/$LOCK_TAG; then
              echo "推送成功"
              exit 0
            fi

            # 冲突应急处理
            git reset --hard origin/${{ github.ref_name }}
            git clean -ffdx
            sleep $((i * 2))
          done

          echo "推送失败，执行终极强制推送"
          git push origin HEAD:${{ github.ref_name }} --force

      # 阶段7：清理锁
      - name: Cleanup Lock
        run: |
          git push --delete origin $LOCK_TAG || true
          git tag -d $LOCK_TAG || true
